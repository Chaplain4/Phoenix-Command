import bisect


class Table1:

    @staticmethod
    def get_base_speed_1a(strength: float, encumbrance: float) -> float:
        """
        Returns the base speed (as float) based on strength and encumbrance from the recognized table.
        Handles intermediate encumbrance values by selecting the next higher encumbrance level.
        Returns 0.0 for encumbrance beyond the table's supported levels or where no value is present in the image.
        Strength is converted to int; raises ValueError if invalid.
        """
        enc_levels = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, 90, 100, 125, 150, 200]

        table = {
            21: [4.5, 4.5, 4.0, 4.0, 4.0, 3.5, 3.5, 3.5, 3.5, 3.5, 3.0, 3.0, 3.0, 3.0, 3.0, 2.5, 2.5, 2.0],
            20: [4.5, 4.0, 4.0, 3.5, 3.5, 3.5, 3.5, 3.5, 3.0, 3.0, 3.0, 3.0, 3.0, 2.5, 2.5, 2.5, 2.5, 2.0],
            19: [4.0, 4.0, 3.5, 3.5, 3.0, 3.0, 3.0, 3.0, 3.0, 2.5, 2.5, 2.5, 2.5, 2.5, 2.0, 2.0, 2.0, 1.5],
            18: [4.0, 3.5, 3.5, 3.0, 3.0, 3.0, 2.5, 2.5, 2.5, 2.5, 2.5, 2.0, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5],
            17: [3.5, 3.0, 3.0, 3.0, 2.5, 2.5, 2.5, 2.5, 2.0, 2.0, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.0],
            16: [3.5, 3.0, 2.5, 2.5, 2.5, 2.5, 2.0, 2.0, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0],
            15: [3.0, 3.0, 2.5, 2.5, 2.0, 2.0, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 0.0],
            14: [3.0, 2.5, 2.5, 2.0, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 0.0],
            13: [3.0, 2.5, 2.5, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0],
            12: [3.0, 2.5, 2.0, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0],
            11: [3.0, 2.5, 2.0, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0],
            10: [3.0, 2.5, 2.0, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0],
            9: [3.0, 2.5, 2.0, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0],
            8: [3.0, 2.5, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0],
            7: [2.5, 2.5, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0],
            6: [2.5, 2.5, 2.0, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0],
            5: [2.5, 2.5, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0],
            4: [2.5, 2.0, 2.0, 1.5, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            3: [2.5, 2.0, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            2: [2.0, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            1: [1.5, 1.5, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        }

        stren = int(strength)
        if stren < 1 or stren > 21:
            raise ValueError("Strength must be between 1 and 21.")

        if encumbrance > enc_levels[-1]:
            return 0.0

        enc_index = 0
        for i in range(len(enc_levels)):
            if enc_levels[i] >= encumbrance:
                enc_index = i
                break

        return table[stren][enc_index]

    @staticmethod
    def get_max_speed_1b(agility: float, base_speed: float) -> float:
        """
        Returns the max speed (as float) based on agility and base speed from the provided matrix.
        Performs exact lookup; returns 0.0 if no exact match is found.
        Agility is converted to int (1-21).
        """
        matrix = {
            21: {1: 2, 1.5: 4, 2: 5, 2.5: 7, 3: 9, 3.5: 10, 4: 12, 4.5: 13},
            20: {1: 2, 1.5: 4, 2: 5, 2.5: 7, 3: 8, 3.5: 10, 4: 11, 4.5: 13},
            19: {1: 2, 1.5: 4, 2: 5, 2.5: 7, 3: 8, 3.5: 10, 4: 11, 4.5: 12},
            18: {1: 2, 1.5: 4, 2: 5, 2.5: 6, 3: 8, 3.5: 9, 4: 11, 4.5: 12},
            17: {1: 2, 1.5: 3, 2: 5, 2.5: 6, 3: 8, 3.5: 9, 4: 10, 4.5: 12},
            16: {1: 2, 1.5: 3, 2: 5, 2.5: 6, 3: 8, 3.5: 9, 4: 10, 4.5: 11},
            15: {1: 2, 1.5: 3, 2: 5, 2.5: 6, 3: 7, 3.5: 9, 4: 10, 4.5: 11},
            14: {1: 2, 1.5: 3, 2: 4, 2.5: 6, 3: 7, 3.5: 8, 4: 9, 4.5: 11},
            13: {1: 2, 1.5: 3, 2: 4, 2.5: 6, 3: 7, 3.5: 8, 4: 9, 4.5: 10},
            12: {1: 2, 1.5: 3, 2: 4, 2.5: 5, 3: 7, 3.5: 8, 4: 9, 4.5: 10},
            11: {1: 2, 1.5: 3, 2: 4, 2.5: 5, 3: 6, 3.5: 7, 4: 8, 4.5: 9},
            10: {1: 2, 1.5: 3, 2: 4, 2.5: 5, 3: 6, 3.5: 7, 4: 8, 4.5: 9},
            9: {1: 2, 1.5: 3, 2: 4, 2.5: 5, 3: 6, 3.5: 7, 4: 8, 4.5: 9},
            8: {1: 2, 1.5: 3, 2: 4, 2.5: 4, 3: 5, 3.5: 6, 4: 7, 4.5: 8},
            7: {1: 2, 1.5: 3, 2: 3, 2.5: 4, 3: 5, 3.5: 6, 4: 7, 4.5: 8},
            6: {1: 2, 1.5: 2, 2: 3, 2.5: 4, 3: 5, 3.5: 5, 4: 6, 4.5: 7},
            5: {1: 1, 1.5: 2, 2: 3, 2.5: 4, 3: 4, 3.5: 5, 4: 6, 4.5: 6},
            4: {1: 1, 1.5: 2, 2: 3, 2.5: 3, 3: 4, 3.5: 4, 4: 5, 4.5: 6},
            3: {1: 1, 1.5: 2, 2: 2, 2.5: 3, 3: 3, 3.5: 4, 4: 4, 4.5: 5},
            2: {1: 1, 1.5: 1, 2: 2, 2.5: 2, 3: 3, 3.5: 3, 4: 4, 4.5: 4},
            1: {1: 1, 1.5: 1, 2: 1, 2.5: 2, 3: 2, 3.5: 2, 4: 3, 4.5: 3}
        }

        agi = int(agility)
        if agi < 1 or agi > 21:
            return 0.0

        if agi not in matrix:
            return 0.0

        if base_speed in matrix[agi]:
            return float(matrix[agi][base_speed])
        else:
            return 0.0

    @staticmethod
    def get_skill_accuracy_level_1Ñ(skill_level: int) -> int:
        """
        Returns the skill accuracy level based on the provided skill level from the mapping table.
        Raises ValueError if skill_level is not between 0 and 20 inclusive.
        """
        mapping = {
            "0": 0, "1": 5, "2": 7, "3": 9, "4": 10, "5": 11, "6": 12,
            "7": 13, "8": 14, "9": 15, "10": 16, "11": 17, "12": 18,
            "13": 19, "14": 20, "15": 21, "16": 22, "17": 23, "18": 24,
            "19": 25, "20": 26
        }

        if skill_level < 0 or skill_level > 20:
            raise ValueError("Skill level must be between 0 and 20.")

        key = str(skill_level)
        return mapping[key]

    @staticmethod
    def get_combat_actions_1d(ms: int, isf: int) -> int:
        """
        Returns the
        """

        ISF_VALUES = [7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]

        TABLE = {
            1: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2],
            2: [1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4],
            3: [1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6],
            4: [2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7],
            5: [2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9],
            6: [3, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11],
            7: [3, 4, 5, 5, 6, 7, 7, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13],
            8: [3, 4, 5, 6, 7, 8, 9, 9, 10, 11, 11, 12, 12, 13, 14, 14, 15],
            9: [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 13, 14, 15, 15, 16, 17],
            10: [4, 6, 7, 8, 9, 10, 11, 12, 12, 13, 14, 15, 16, 16, 17, 18, 18],
            11: [5, 6, 7, 9, 10, 11, 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20],
            12: [5, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 21, 22],
            13: [6, 7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
        }


        if ms not in TABLE:
            raise ValueError(f"No data for MS={ms}")

        if isf <= ISF_VALUES[0]:
            quantized_isf = ISF_VALUES[0]
        elif isf >= ISF_VALUES[-1]:
            quantized_isf = ISF_VALUES[-1]
        else:
            pos = bisect.bisect_left(ISF_VALUES, isf)
            quantized_isf = ISF_VALUES[pos]

        col_index = ISF_VALUES.index(quantized_isf)
        return TABLE[ms][col_index]